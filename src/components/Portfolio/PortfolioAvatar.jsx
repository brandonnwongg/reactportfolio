/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/PortfolioAvatar.glb 
*/

import { useAnimations, useFBX, useGLTF, useScroll } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import React, { useEffect, useRef, useState } from "react";

import * as THREE from "three";

export function PortfolioAvatar(props) {
  const { nodes, materials } = useGLTF(
    import.meta.env.BASE_URL + "models/PortfolioAvatar.glb"
  );

  const { animations: enteringFallAnimation } = useFBX(
    import.meta.env.BASE_URL + "animations/enteringfall.fbx"
  );
  const { animations: standingAnimation } = useFBX(
    import.meta.env.BASE_URL + "animations/stand.fbx"
  );
  const { animations: neutralAnimation } = useFBX(
    import.meta.env.BASE_URL + "animations/idle.fbx"
  );
  const { animations: wavingAnimation } = useFBX(
    import.meta.env.BASE_URL + "animations/wave.fbx"
  );
  const { animations: walkingAnimation } = useFBX(
    import.meta.env.BASE_URL + "animations/walking.fbx"
  );

  const group = useRef();
  enteringFallAnimation[0].name = "Entering Fall";
  standingAnimation[0].name = "Standing";
  neutralAnimation[0].name = "Neutral";
  wavingAnimation[0].name = "Waving";
  walkingAnimation[0].name = "Walking";

  const { actions } = useAnimations(
    [
      enteringFallAnimation[0],
      standingAnimation[0],
      neutralAnimation[0],
      wavingAnimation[0],
      walkingAnimation[0],
    ],
    group
  );
  //from here
  const [ready, setReady] = useState(false);
  const [startupComplete, setStartupComplete] = useState(false);
  const [currentStage, setCurrentStage] = useState(null); // Start with null

  const currentAction = useRef(null);
  const hasTransitioned = useRef(false);
  const currentIndex = useRef(0);
  const sequence = useRef(["Standing", "Neutral"]);

  // Wait until all needed animations are loaded
  useEffect(() => {
    if (actions["Entering Fall"] && actions["Standing"] && actions["Neutral"]) {
      setReady(true);
    }
  }, [actions]);

  // When ready, begin the sequence
  useEffect(() => {
    if (ready) {
      setCurrentStage("Entering Fall");
    }
  }, [ready]);

  // Play currentStage when itâ€™s set
  useEffect(() => {
    if (!currentStage || !actions[currentStage]) return;

    const action = actions[currentStage];
    currentAction.current = action;
    hasTransitioned.current = false;

    action.reset().play();

    if (currentStage !== "Neutral") {
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
    }

    if (currentStage === "Standing") {
      action.setEffectiveTimeScale(4);
    }

    return () => {
      action.stop();
    };
  }, [currentStage, actions]);

  // Detect when current animation finishes and move to next
  useFrame(() => {
    const action = currentAction.current;
    if (!action || hasTransitioned.current || !action.isRunning()) return;

    if (action.time >= action._clip.duration - 0.1) {
      hasTransitioned.current = true;

      if (currentIndex.current < sequence.current.length) {
        const next = sequence.current[currentIndex.current++];
        setCurrentStage(next);
      } else {
        setStartupComplete(true);
      }
    }
  });

  const [animation, setAnimation] = useState("Neutral"); // Default idle pose
  const [isHovering, setIsHovering] = useState(false);

  useEffect(() => {
    const active = startupComplete ? animation : currentStage;
    if (!actions || !actions[active]) return;

    actions[active].reset().play();

    return () => {
      if (actions[active]) {
        actions[active].reset().stop();
      }
    };
  }, [animation, currentStage, actions, startupComplete]);

  const scrollData = useScroll();
  const lastScroll = useRef(0);

  useFrame(() => {
    const scrollDelta = scrollData.offset - lastScroll.current;

    if (!startupComplete && Math.abs(scrollDelta) > 0.0001) {
      setStartupComplete(true);
      setCurrentStage(null);
      setAnimation("Walking");
      currentAction.current?.stop();
      return;
    }

    if (startupComplete) {
      if (Math.abs(scrollDelta) > 0.0001) {
        setAnimation("Walking");

        group.current.rotation.y = THREE.MathUtils.lerp(
          group.current.rotation.y,
          scrollDelta > 0 ? 0 : Math.PI,
          0.1
        );
      } else {
        if (isHovering) {
          setAnimation("Waving");
        } else {
          setAnimation("Neutral");
        }
      }
      lastScroll.current = scrollData.offset;
    }
  });

  return (
    <group
      {...props}
      dispose={null}
      ref={group}
      onPointerEnter={() => setIsHovering(true)}
      onPointerLeave={() => setIsHovering(false)}
    >
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Glasses.geometry}
        material={materials.Wolf3D_Glasses}
        skeleton={nodes.Wolf3D_Glasses.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
}

useGLTF.preload(import.meta.env.BASE_URL + "models/PortfolioAvatar.glb");
useFBX.preload(import.meta.env.BASE_URL + "animations/enteringfall.fbx");
useFBX.preload(import.meta.env.BASE_URL + "animations/stand.fbx");
useFBX.preload(import.meta.env.BASE_URL + "animations/neutral.fbx");
useFBX.preload(import.meta.env.BASE_URL + "animations/walking.fbx");
useFBX.preload(import.meta.env.BASE_URL + "animations/wave.fbx");
