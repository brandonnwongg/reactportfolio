/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/PortfolioAvatar.glb 
*/

import { useAnimations, useFBX, useGLTF, useScroll } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import React, { useEffect, useRef, useState } from "react";

import * as THREE from "three";

export function PortfolioAvatar(props) {
  // const { animation } = props;

  const { nodes, materials } = useGLTF("/models/PortfolioAvatar.glb");

  const { animations: enteringFallAnimation } = useFBX(
    "/animations/enteringfall.fbx"
  );
  const { animations: standingAnimation } = useFBX("/animations/stand.fbx");
  const { animations: neutralAnimation } = useFBX("/animations/neutral.fbx");
  // const { animations: fallingAnimation } = useFBX("/animations/fall.fbx");
  const { animations: wavingAnimation } = useFBX("/animations/wave.fbx");
  const { animations: walkingAnimation } = useFBX("/animations/walking.fbx");

  const group = useRef();
  enteringFallAnimation[0].name = "Entering Fall";
  standingAnimation[0].name = "Standing";
  neutralAnimation[0].name = "Neutral";
  // fallingAnimation[0].name = "Fall";
  wavingAnimation[0].name = "Waving";
  walkingAnimation[0].name = "Walking";

  const { actions } = useAnimations(
    [
      enteringFallAnimation[0],
      standingAnimation[0],
      neutralAnimation[0],
      // fallingAnimation[0],
      wavingAnimation[0],
      walkingAnimation[0],
    ],
    group
  );

  const [ready, setReady] = useState(false);
  const [currentStage, setCurrentStage] = useState(null); // Start with null
  const currentAction = useRef(null);
  const hasTransitioned = useRef(false);
  const currentIndex = useRef(0);
  const sequence = useRef(["Standing", "Neutral"]);

  // Wait until all needed animations are loaded
  useEffect(() => {
    if (actions["Entering Fall"] && actions["Standing"] && actions["Neutral"]) {
      setReady(true);
    }
  }, [actions]);

  // When ready, begin the sequence
  useEffect(() => {
    if (ready) {
      setCurrentStage("Entering Fall");
    }
  }, [ready]);

  // Play currentStage when itâ€™s set
  useEffect(() => {
    if (!currentStage || !actions[currentStage]) return;

    const action = actions[currentStage];
    currentAction.current = action;
    hasTransitioned.current = false;

    action.reset().play();

    if (currentStage !== "Neutral") {
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
    }

    if (currentStage === "Standing") {
      action.setEffectiveTimeScale(3.5);
    }

    return () => {
      action.stop();
    };
  }, [currentStage, actions]);

  // Detect when current animation finishes and move to next
  useFrame(() => {
    const action = currentAction.current;
    if (!action || hasTransitioned.current || !action.isRunning()) return;

    if (action.time >= action._clip.duration - 0.1) {
      hasTransitioned.current = true;

      if (currentIndex.current < sequence.current.length) {
        const next = sequence.current[currentIndex.current++];
        setCurrentStage(next);
      }
    }
  });

  // const stopAllAnimations = () => {
  //   Object.values(actions).forEach((action) => {
  //     if (action.isRunning()) {
  //       action.stop();
  //     }
  //   });
  // };

  // const [animation, setAnimation] = useState("Neutral"); // Default idle pose

  // useEffect(() => {
  //   if (!actions || !actions[animation]) return;

  //   actions[animation].reset().fadeIn(0.5).play();

  //   return () => {
  //     if (actions[animation]) {
  //       actions[animation].reset().fadeOut(0.5).stop();
  //     }
  //   };
  // }, [animation, actions]);

  // const scrollData = useScroll();
  // const lastScroll = useRef(0);

  // useFrame(() => {
  //   const scrollDelta = scrollData.offset - lastScroll.current;
  //   let rotationTarget = 0;
  //   if (Math.abs(scrollDelta) > 0.0001) {
  //     stopAllAnimations();
  //     if (scrollDelta > 0) {
  //       rotationTarget = 0;
  //     } else {
  //       rotationTarget = Math.PI;
  //     }
  //   } else {
  //     setAnimation("Waving");
  //   }
  //   group.current.rotation.y = THREE.MathUtils.lerp(
  //     group.current.rotation.y,
  //     rotationTarget,
  //     0.1
  //   );
  //   lastScroll.current = scrollData.offset;
  // });
  // useFrame(() => {
  //   const scrollDelta = scrollData.offset - lastScroll.current;

  //   if (Math.abs(scrollDelta) > 0.0001) {
  //     stopAllAnimations(); // Immediately stop ongoing animation
  //     setAnimation("Walking");

  //     group.current.rotation.y = THREE.MathUtils.lerp(
  //       group.current.rotation.y,
  //       scrollDelta > 0 ? 0 : Math.PI,
  //       0.1
  //     );
  //   } else {
  //     setAnimation("Neutral");
  //   }

  //   lastScroll.current = scrollData.offset;
  // });

  // useEffect(() => {
  //   if (!actions || !animation || !actions[animation]) return;

  //   const action = actions[animation];
  //   action.reset().fadeIn(0.2).play();

  //   return () => {
  //     action.fadeOut(0.2).stop();
  //   };
  // }, [animation, actions]);

  return (
    <group
      {...props}
      dispose={null}
      ref={group}
      onPointerEnter={() => setAnimation("Waving")}
      onPointerLeave={() => setAnimation("Neutral")}
    >
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Glasses.geometry}
        material={materials.Wolf3D_Glasses}
        skeleton={nodes.Wolf3D_Glasses.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
}

useGLTF.preload("/models/PortfolioAvatar.glb");
useFBX.preload("/animations/enteringfall.fbx");
useFBX.preload("/animations/stand.fbx");
useFBX.preload("/animations/neutral.fbx");
useFBX.preload("/animations/walking.fbx");
useFBX.preload("/animations/wave.fbx");
